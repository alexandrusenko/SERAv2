# Архитектура «умного» локального агента без упора на скорость

## 1) Главные проблемы и как они закрываются

- **Слабый reasoning локальной модели** → вводим двухконтурный цикл:
  - контур A: строгий planner (JSON-план);
  - контур B: executor с валидацией, retry и пост-проверкой результата.
- **Бесконечные циклы/сдача** → budget шагов + детектор повторов + принудительный переход в режим self-repair.
- **Память и туннельный RAG** → гибрид памяти:
  - свежий контекст (последние N событий),
  - долговременная SQLite память,
  - целевой retrieval по ключевым токенам и ролям,
  - принудительный memory summary через интервалы.
- **Нет нужной функции** → self-improvement модуль:
  1. диагностика отсутствующего tool;
  2. генерация безопасного плагина кодом;
  3. статическая AST-проверка;
  4. hot-load в реестр инструментов.

## 2) Почему tool-calling + code-writing вместе

- Только tool-calling ограничен заранее известным набором возможностей.
- Только «писать код под каждую задачу» слишком рискованно и нестабильно.
- **Комбинация**:
  - базовые безопасные инструменты (файлы/HTTP/shell по политике);
  - при нехватке capabilities агент создает *новый* tool, валидирует и подключает.

Итог: управляемая адаптивность без полной анархии.

## 3) Рекомендованный runtime для ваших моделей

- Библиотека: **llama-cpp-python** (GGUF, CUDA offload, Windows-friendly).
- Роль моделей:
  - Qwen3.5-27B-Q4_K_M — главный планировщик + исполнитель;
  - Qwen2.5-Coder-32B-Q4_K_M — генерация/ревью кода и self-improvement;
  - Qwen2.5-14B-Q5_K_M — быстрые черновики/классификация.

## 4) Производственные guardrails

- строгий JSON-контракт для планов и step execution;
- лимиты шагов и ретраев;
- policy engine (shell/network/path/import restrictions);
- обязательные логи на каждом переходе состояния;
- трассировка tool calls.

## 5) Поток выполнения

1. User task → запись в память.
2. Planner генерирует план.
3. Executor выполняет шаги через tools.
4. При ошибках/пробелах capability → self-improver создает plugin.
5. Plugin проходит safety-проверку и hot-load.
6. Выполнение продолжается с новой capability.
7. Итог и summary записываются в память.

## 6) Ограничение текущей среды

В этой среде интернет-запросы (curl к внешним источникам) блокируются прокси (HTTP 403 CONNECT tunnel failed),
поэтому фактическую web-верификацию model cards нужно выполнить у вас локально.
